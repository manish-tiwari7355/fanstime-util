const dns = require('dns');
const { createResolverSrv, resolveSrv } = require('./dns');

const kOptions = Symbol('options');
const kTargets = Symbol('targets');

const defaultTtl = 5;
const defaultMaxStale = 120;
const defaultMaxRetryWait = 30;

const createError = (code, msg) => Object.assign(new Error(msg), { code });

const errNodata = createError(dns.NODATA, 'no address is available');
const errMaxStale = createError(dns.SERVFAIL, 'cached data is older than maxStale seconds');

const withDefault = (value, defaultValue) => (
	value === undefined ? defaultValue : value);

/**
 * Returns whether the error is a connection error which is worty of a re-try.
 */
const isConnectionError = err => (
	typeof err === 'object' &&
	err !== null &&
	err.code === 'ECONNREFUSED');

/**
 * Returns whether two address objects point to the same host and port.
 */
const cmpAddrs = (a, b) => (
	a.hostname === b.hostname &&
	a.port === b.port);

/**
 * Get monotonic time, in seconds.
 */
function now() {
	const [sec, usec] = process.hrtime();
	return sec + (usec / 1E9);
}

function getTarget(agent, hostname) {
	if (!agent[kTargets][hostname]) {
		agent[kTargets][hostname] = new Target(agent[kOptions], hostname);
	}
	return agent[kTargets][hostname];
}

function appendAddr(prev, addr) {
	if (prev) {
		addr.next = prev.next;
		prev.next = addr;
	} else {
		addr.next = addr;
	}
	return addr;
}

class Address {
	constructor(hostname, port) {
		this.hostname = hostname;
		this.port = port;
	}

	toString() {
		return `${this.hostname}:${this.port}`;
	}
}

class Target {
	constructor(options, hostname) {
		this.resolver = options.nameservers ?
			createResolverSrv(options.nameservers) :
			resolveSrv;

		this.resolverOptions = {
			timeoutMs: options.resolveTimeoutMs,
		};

		this.maxStale = withDefault(options.maxStale, defaultMaxStale);
		this.maxRetryWait = withDefault(options.maxRetryWait, defaultMaxRetryWait);
		this.hostname = hostname;

		this.getTime = now;

		this.ttl = defaultTtl;
		this.addr = undefined;

		/**
		 * Indicates that all addresses in this.addr have the "failed" flag
		 * set, so there's no point in searching for any good ones.
		 */
		this.allFailed = false;

		this.err = undefined;
		this.errSeq = 0;

		this.renewPromise = undefined;

		/**
		 * Time AFTER which a renewal attempt must happen.
		 */
		this.renewNextAfter = 0;

		/**
		 * Time AFTER which stale data may no longer be used.
		 */
		this.maxStaleAt = undefined;
	}

	resolve() {
		return this.renewIfNeeded().then(() => {
			if (this.isTooStale()) {
				throw this.createError(this.err || errMaxStale);
			}

			if (this.addr === undefined) {
				throw this.createError(this.err || errNodata);
			}

			let addr = this.addr;

			// The current selected address has been marked as "failed". Look
			// for the next non-failed one.
			if (addr.failed && !this.allFailed) {
				const begin = addr;
				do {
					addr = addr.next;
				} while (addr !== begin && addr.failed);
			}

			this.addr = addr.next;

			return new Address(addr.hostname, addr.port);
		});
	}

	/**
	 * Indicate that the provided address is bad.
	 */
	complain(addr) {
		if (this.allFailed || this.addr === undefined) {
			return;
		}

		const begin = this.addr;
		let search = begin;

		do {
			if (cmpAddrs(search, addr)) {
				search.failed = true;
			}
			search = search.next;
		} while (search !== begin);
	}

	/**
	 * @return {Promise}
	 */
	renewIfNeeded() {
		let promise;

		if (this.getTime() > this.renewNextAfter) {
			promise = this.renew();

			if (this.addr !== undefined && !this.isTooStale()) {
				// We have stale data that's still good enough. Don't wait for
				// the renewal to complete.
				promise = Promise.resolve();
			}
		} else {
			promise = Promise.resolve();
		}

		return promise;
	}

	isTooStale() {
		return this.maxStaleAt !== undefined && this.maxStaleAt < this.getTime();
	}

	renew() {
		if (!this.renewPromise) {
			this.renewPromise = this.resolver(this.hostname, this.resolverOptions).then(
				(addrs) => {
					let prevAddr;
					let newTtl;

					for (const { name, port, ttl } of addrs) {
						prevAddr = appendAddr(prevAddr, {
							hostname: name,
							port,
							failed: false,
						});

						// Pick the smallest TTL value as the new one.
						if (!newTtl || ttl < newTtl) {
							newTtl = ttl;
						}
					}

					if (!newTtl || !(newTtl > defaultTtl)) {
						newTtl = defaultTtl;
					}

					this.ttl = newTtl;
					this.addr = prevAddr.next;
					this.allFailed = false;
					this.err = undefined;
					this.errSeq = 0;

					this.maxStaleAt = this.getTime() + this.ttl + this.maxStale;
					this.renewNextAfter = this.getTime() + this.ttl;
				},
				(err) => {
					this.err = err;
					this.errSeq++;

					this.renewNextAfter = this.getTime() + this.getRetryWait(this.errSeq);
				},
			).then(() => {
				this.renewPromise = undefined;
			});
		}

		return this.renewPromise;
	}

	/**
	 * Get the number of seconds to wait before re-trying after an error.
	 */
	getRetryWait(seq) {
		return Math.min(Math.pow(2, seq) + Math.random() * 2, this.maxRetryWait);
	}

	createError(err) {
		const retry = (this.renewNextAfter - this.getTime()).toFixed(3);
		const msg = `${err.message}; re-trying after ${retry} seconds`;

		return Object.assign(new Error(msg), {
			code: err.code,
		});
	}
}

class Agent {
	/**
	 * @param {Object} [options]
	 * @param {number} [options.maxStale]
	 * @param {number} [options.maxRetryWait]
	 * @param {number} [options.resolveTimeoutMs]
	 * @param {string} [options.nameservers]
	 */
	constructor(options = {}) {
		this[kOptions] = Object.assign({}, options);
		this[kTargets] = {};
	}

	/**
	 * @param {string} hostname
	 * @return {Promise<string>}
	 */
	resolve(hostname) {
		return getTarget(this, hostname).resolve();
	}

	/**
	 * Resolves hostname and then calls callback with the resolved address.
	 * Returns a promise which resolves to the return value of the callback.
	 *
	 * The maxRetries option indicates how many times the callback may be
	 * re-tries in case it returns a connection error. For example, if
	 * maxRetries is equal to 2, then callback could be called a total of 3
	 * times.
	 *
	 * What constitutes a "connection error" can be customized using the "test"
	 * option: a function which will receive an error as its argument and is
	 * expected to return a boolean indicating whether the error is a
	 * connection error.
	 *
	 * @param {string} hostname
	 * @param {Object} [options]
	 * @param {number} [options.maxRetries]
	 * @param {function} [options.test]
	 * @param {function} callback
	 * @return {Promise}
	 */
	resolveFor(hostname, /* options, */ callback) {
		let options;

		if (arguments.length >= 3 && typeof callback === 'object') {
			options = callback;
			callback = arguments[2];
		} else {
			options = {};
		}

		const testError = options.test || isConnectionError;
		const maxCount = (options.maxRetries || 0) + 1;

		return new Promise((resolve, reject) => {
			let count = 1;

			const target = getTarget(this, hostname);
			const doTry = () => target.resolve(hostname).then((addr) => {
				return callback(addr).then(resolve, (err) => {
					const repeatable = testError(err);

					if (repeatable) {
						target.complain(addr);
					}

					if (count >= maxCount || !repeatable) {
						reject(err);
					} else {
						count++;
						doTry();
					}
				});
			});

			doTry();
		});
	}
}

module.exports = { Agent, Target, kTargets };
