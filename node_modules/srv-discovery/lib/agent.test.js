const assert = require('assert');
const { EventEmitter } = require('events');
const dns = require('dns');

const { Agent, Target, kTargets } = require('./agent');

const assertRejects = async (func, errback) => func().then(
	() => assert.fail('did not reject'),
	errback,
);

function defer() {
	const deferred = {};
	deferred.promise = new Promise((resolve, reject) => {
		deferred.resolve = resolve;
		deferred.reject = reject;
	});
	return deferred;
}

describe('Target', function () {
	describe('#renew()', function () {
		it('should not cause multiple parallel DNS queries', function () {
			let calls = 0;

			const target = new Target({});
			target.resolver = () => {
				calls++;
				return new Promise(() => undefined);
			};

			setTimeout(() => target.renew(), 0);
			setTimeout(() => target.renew(), 0);
			setTimeout(() => target.renew(), 0);

			setTimeout(() => {
				assert.strictEqual(calls, 1);
			}, 0);
		});
	});

	describe('#resolve()', function () {
		it('should renew after TTL has elapsed', async function () {
			let calls = 0;
			let time;

			const target = new Target({});

			target.getTime = () => time;
			target.getRetryWait = () => 10;
			target.resolver = async () => {
				calls++;
				return [{ name: 'foo.com', port: 80, ttl: 20 }];
			};

			time = 10;
			await target.resolve();
			assert.strictEqual(calls, 1);

			time = 20;
			await target.resolve();
			assert.strictEqual(calls, 1);

			time = 30;
			await target.resolve();
			assert.strictEqual(calls, 1);

			time = 30.1;
			await target.resolve();
			assert.strictEqual(calls, 2);

			time = 40;
			await target.resolve();
			assert.strictEqual(calls, 2);

			time = 50;
			await target.resolve();
			assert.strictEqual(calls, 2);
		});

		it('should return addresses in sequence', async function () {
			const target = new Target({});
			target.resolver = async () => [
				{ name: 'one', port: 80, ttl: 20 },
				{ name: 'two', port: 80, ttl: 20 },
				{ name: 'three', port: 80, ttl: 20 },
				{ name: 'four', port: 80, ttl: 20 },
			];

			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
			assert.strictEqual(String(await target.resolve()), 'three:80');
			assert.strictEqual(String(await target.resolve()), 'four:80');
			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
		});

		it('should re-throw error from first renewal and be able to recover', async function () {
			const target = new Target({});

			target.getTime = () => 10;
			target.getRetryWait = () => 5;
			target.resolver = async () => {
				throw Object.assign(new Error('no data'), { code: dns.NODATA });
			};

			await assertRejects(
				() => target.resolve(),
				(err) => {
					assert.strictEqual(err.code, dns.NODATA);
					assert.strictEqual(err.message, 'no data; re-trying after 5.000 seconds');
				},
			);

			target.getTime = () => 15.1;
			target.resolver = async () => [
				{ name: 'foo.com', port: 80, ttl: 10 },
			];

			assert.strictEqual(String(await target.resolve()), 'foo.com:80');
		});

		it('should throw when data is past maxStale age', async function () {
			let time = 10;
			const target = new Target({ maxStale: 10 });

			target.getTime = () => time;
			target.getRetryWait = () => 10;
			target.resolver = async () => [
				{ name: 'foo.com', port: 80, ttl: 10 },
			];

			// Perform the first successful renewal.
			await target.resolve();

			// Make sure further renewals fail.
			target.resolver = async () => {
				throw Object.assign(new Error('no data'), { code: dns.NODATA });
			};

			// TTL has passed and new renewal will be performed. It will fail,
			// but stale data can still be used.
			time = 21;
			await target.resolve();

			// This is the last second on which stale data is allowed.
			time = 30;
			await target.resolve();

			// Max staleness has elapsed. This is an error.
			time = 30.1;
			await assertRejects(
				() => target.resolve(),
				(err) => {
					assert.strictEqual(err.code, dns.NODATA);
					assert.strictEqual(err.message, 'no data; re-trying after 0.900 seconds');
				},
			);
		});

		it('should not return stale data when maxStale is 0', async function () {
			let time = 10;
			const target = new Target({ maxStale: 0 });

			target.getTime = () => time;
			target.getRetryWait = () => 10;
			target.resolver = async () => [
				{ name: 'foo.com', port: 80, ttl: 10 },
			];

			// Perform the first successful renewal.
			await target.resolve();

			// Make further renewals fail.
			target.resolver = async () => {
				throw Object.assign(new Error('no data'), { code: dns.NODATA });
			};

			time = 20;
			await target.resolve();

			time = 20.1;
			await assertRejects(
				() => target.resolve(),
				(err) => {
					assert.strictEqual(err.code, dns.NODATA);
					assert.strictEqual(err.message, 'no data; re-trying after 10.000 seconds');
				},
			);
		});

		it('should incrementally increase retry time on error', async function () {
			const target = new Target({ maxRetryWait: 31 });

			let wait = target.getRetryWait(1);
			assert(wait >= 2 && wait <= 4);

			wait = target.getRetryWait(2);
			assert(wait >= 4 && wait <= 6);

			wait = target.getRetryWait(3);
			assert(wait >= 8 && wait <= 10);

			wait = target.getRetryWait(4);
			assert(wait >= 16 && wait <= 18);

			wait = target.getRetryWait(5);
			assert(wait >= 30 && wait <= 31);
		});

		it('should not wait for renewal to complete when under maxStale limit', async function () {
			let time = 10;
			const target = new Target({ maxStale: 10 });

			target.getTime = () => time;
			target.resolver = async () => [
				{ name: 'foo.com', port: 80, ttl: 5 },
			];

			// Perform the first successful renewal.
			await target.resolve();

			const deferred = defer();
			let didRenew = 0;

			target.resolver = () => {
				didRenew++;
				return deferred.promise;
			};

			// Data is now stale and renewal will need to be performed.
			time = 16;
			assert.strictEqual(String(await target.resolve()), 'foo.com:80');
			assert.strictEqual(didRenew, 1);
			assert.strictEqual(String(await target.resolve()), 'foo.com:80');
			assert.strictEqual(didRenew, 1);

			deferred.resolve([
				{ name: 'bar.com', port: 80, ttl: 5 },
			]);

			assert.strictEqual(String(await target.resolve()), 'bar.com:80');
			assert.strictEqual(didRenew, 1);
		});

		it('should wait for renewal to complete when stale data is disallowed', async function () {
			let time = 10;
			const target = new Target({ maxStale: 0 });

			target.getTime = () => time;
			target.resolver = async () => [
				{ name: 'foo.com', port: 80, ttl: 5 },
			];

			// Perform the first successful renewal.
			await target.resolve();

			// If "resolve()" rejects, then we can be sure that it waited for
			// the renewal to finish.
			target.renew = async () => {
				throw new Error('did wait for renewal');
			};

			// Data is now stale and renewal will need to be performed.
			time = 16;

			await assertRejects(
				() => target.resolve(),
				(err) => {
					assert.strictEqual(err.message, 'did wait for renewal');
				},
			);
		});

		it('should skip failed addresses as long as there are good ones', async function () {
			const target = new Target({});

			target.resolver = async () => [
				{ name: 'one', port: 80, ttl: 5 },
				{ name: 'two', port: 80, ttl: 5 },
				{ name: 'three', port: 80, ttl: 5 },
				{ name: 'four', port: 80, ttl: 5 },
			];

			// Complaining when nothing is loaded has no effect
			target.complain({ hostname: 'one', port: 80 });

			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');

			// Complain directly after address was resolved
			target.complain({ hostname: 'two', port: 80 });

			assert.strictEqual(String(await target.resolve()), 'three:80');
			assert.strictEqual(String(await target.resolve()), 'four:80');
			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'three:80');
			assert.strictEqual(String(await target.resolve()), 'four:80');

			// Complain just before the address is about to be returned
			target.complain({ hostname: 'one', port: 80 });

			assert.strictEqual(String(await target.resolve()), 'three:80');
			assert.strictEqual(String(await target.resolve()), 'four:80');
			assert.strictEqual(String(await target.resolve()), 'three:80');

			// Make all addresses fail.
			target.complain({ hostname: 'four', port: 80 });
			target.complain({ hostname: 'three', port: 80 });

			// Complaining when all addresses have failed has no effect
			target.complain({ hostname: 'three', port: 80 });

			assert.strictEqual(String(await target.resolve()), 'four:80');
			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
			assert.strictEqual(String(await target.resolve()), 'three:80');
			assert.strictEqual(String(await target.resolve()), 'four:80');
		});

		it('should un-mark failed addresses during renewal', async function () {
			const target = new Target({ maxStale: 0 });

			target.getTime = () => 100;
			target.resolver = async () => [
				{ name: 'one', port: 80, ttl: 5 },
				{ name: 'two', port: 80, ttl: 5 },
			];

			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
			target.complain({ hostname: 'two', port: 80 });

			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'one:80');

			target.getTime = () => 110;

			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
			assert.strictEqual(String(await target.resolve()), 'one:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
		});
	});
});

describe('Agent', function () {
	let agent;
	let target;

	beforeEach(function () {
		agent = new Agent();
		agent[kTargets]['_foo._tcp.local'] = target = new Target({});
	});

	describe('#resolveFor()', function () {
		it('should complain about failed address', async function () {
			target.resolver = async () => [
				{ name: 'one', port: 80, ttl: 5 },
				{ name: 'two', port: 80, ttl: 5 },
			];

			const addrArgs = [];

			const result = agent.resolveFor('_foo._tcp.local', (addr) => {
				addrArgs.push(String(addr));
				return Promise.reject(Object.assign(new Error('connection was refused'), {
					code: 'ECONNREFUSED',
				}));
			});

			// Check that the error is also forwarded back to the application
			await assertRejects(
				() => result,
				(err) => {
					assert.strictEqual(err.code, 'ECONNREFUSED');
					assert.strictEqual(err.message, 'connection was refused');
				},
			);

			assert.deepEqual(addrArgs, ['one:80']);

			// Make sure the failed address is not returned anymore.
			assert.strictEqual(String(await target.resolve()), 'two:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
		});

		it('should not complain on other errors', async function () {
			target.resolver = async () => [
				{ name: 'one', port: 80, ttl: 5 },
				{ name: 'two', port: 80, ttl: 5 },
			];

			const result = agent.resolveFor('_foo._tcp.local', (addr) => {
				return Promise.reject(new Error('something'));
			});

			// Check that the error is forwarded back to the application
			await assertRejects(
				() => result,
				(err) => {
					assert.strictEqual(err.message, 'something');
				},
			);

			// No addresses were complained about
			assert.strictEqual(String(await target.resolve()), 'two:80');
			assert.strictEqual(String(await target.resolve()), 'one:80');
		});

		it('should repeat callback on failure', async function () {
			target.resolver = async () => [
				{ name: 'one', port: 80, ttl: 5 },
				{ name: 'two', port: 80, ttl: 5 },
			];

			const addrArgs = [];
			const result = await agent.resolveFor(
				'_foo._tcp.local',
				{ maxRetries: 2 },
				(addr) => {
					addrArgs.push(String(addr));
					if (addr.hostname === 'two') {
						return Promise.resolve('success');
					}
					return Promise.reject(Object.assign(new Error('connection was refused'), {
						code: 'ECONNREFUSED',
					}));
				},
			);

			assert.deepEqual(addrArgs, ['one:80', 'two:80']);
			assert.strictEqual(result, 'success');

			// Two is the only remaining non-failed address
			assert.strictEqual(String(await target.resolve()), 'two:80');
			assert.strictEqual(String(await target.resolve()), 'two:80');
		});
	});
});
