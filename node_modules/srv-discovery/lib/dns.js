const dgram = require('dgram');
const dns = require('dns');
const { EventEmitter } = require('events');
const Packet = require('native-dns-packet');

const { parseIp } = require('./ip');

const createError = (code, msg) => Object.assign(new Error(msg), { code });

const defaultPort = 53;
const defaultTimeoutMs = 1000;

let defaultResolverSrv;

/**
 * RFC-1034 http://tools.ietf.org/html/rfc1034
 *
 * Label limited to 63 chars and 253 chars max in total length labels cannot
 * start or end with a hyphen "-" and can only have "-a-zA-Z0-9_" characters
 * underscore is used for SRV requests.
 */
const isValidLabel = label => (
	label.length <= 253 &&
	label.match(/^(?:(?!-)(?:[-\w]){0,62}[a-zA-Z0-9]\.)*(?!-)(?:[-\w]){1,62}[a-zA-Z0-9]$/));

const randomId = () => Math.floor(Math.random() * 50000 + 1);

const mapSrvAnswer = ans => ({
	name: ans.target,
	port: ans.port,
	priority: ans.priority,
	weight: ans.weight,
	ttl: ans.ttl,
});

/**
 * @param {number} id
 * @param {string} hostname
 * @return {Buffer}
 */
function encodeSrvQuestion(id, hostname) {
	const packet = new Packet();
	packet.header.id = id;
	packet.header.rd = 1;
	packet.question.push({
		name: hostname,
		type: Packet.consts.NAME_TO_QTYPE.SRV,
		class: Packet.consts.NAME_TO_QCLASS.IN,
	});

	const buf = Buffer.alloc(4096);
	const len = Packet.write(buf, packet);

	return buf.slice(0, len);
}

class Socket extends EventEmitter{
	constructor(addr) {
		super();

		this.addr = addr;
		this.socket = undefined;
		this.inFlight = {};
	}

	bind() {
		this.socket = dgram.createSocket('udp' + this.addr.family);

		this.socket.on('message', (buf) => {
			const packet = Packet.parse(buf);
			const callback = this.inFlight[packet.header.id];

			if (callback) {
				setTimeout(() => callback(null, packet), 0);
				delete this.inFlight[packet.header.id];
			}
		});

		this.socket.on('close', (err) => {
			if (!err) {
				err = createError(dns.TIMEOUT);
			}

			for (const id of Object.keys(this.inFlight)) {
				this.inFlight[id](err);
			}

			this.inFlight = {};

			this.socket.close();
			this.socket = undefined;

			this.emit('close');
		});

		this.socket.bind();
	}

	resolveSrv(hostname, options) {
		const timeoutMs = options && options.timeoutMs || defaultTimeoutMs;

		return new Promise((resolve, reject) => {
			let timer;
			let id;

			do {
				id = randomId();
			} while (this.inFlight[id]);

			this.inFlight[id] = (err, packet) => {
				if (err) {
					reject(err);
				} else {
					resolve(packet.answer.map(mapSrvAnswer));
				}
				clearTimeout(timer);
			};

			timer = setTimeout(() => {
				reject(createError(dns.TIMEOUT));
				delete this.inFlight[id];
			}, timeoutMs);

			const packet = encodeSrvQuestion(id, hostname);
			this.socket.send(packet, this.addr.port || defaultPort, this.addr.ip);
		});
	}
}

function createResolverSrv(servers) {
	// TODO: use the other servers as fallback
	const server = parseIp(servers[0]);
	let socket;

	if (!server) {
		throw new Error(`invalid server name '${servers[0]}`);
	}

	return (hostname, options) => {
		if (!isValidLabel(hostname)) {
			return Promise.reject(createError(dns.BADNAME));
		}

		if (!socket) {
			socket = new Socket(server);
			socket.bind();

			socket.once('close', () => {
				socket = undefined;
			});
		}

		return socket.resolveSrv(hostname, options);
	};
}

function resolveSrv(hostname, options) {
	if (!defaultResolverSrv) {
		defaultResolverSrv = createResolverSrv(dns.getServers());
	}
	return defaultResolverSrv(hostname, options);
}

module.exports = {
	createResolverSrv,
	resolveSrv,
};
